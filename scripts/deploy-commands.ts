import 'dotenv/config';
import { REST, Routes } from 'discord.js';
import fg from 'fast-glob';
import { pathToFileURL } from 'url';
import fs from 'node:fs';

const token = process.env.DISCORD_TOKEN!;
const clientId = process.env.DISCORD_CLIENT_ID!;
const isGuild = process.argv.includes('--guild');
const useDist = process.argv.includes('--dist');   // <-- ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÇ‡∏´‡∏•‡∏î‡∏à‡∏≤‡∏Å dist
const dryRun  = process.argv.includes('--dry');    // <-- ‡∏î‡∏π‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡πÄ‡∏â‡∏¢ ‡πÜ ‡πÑ‡∏°‡πà‡∏≠‡∏±‡∏õ‡πÇ‡∏´‡∏•‡∏î
const guildId = isGuild ? (process.env.DEV_GUILD_ID || '') : '';

type CmdJSON = { name: string; type?: number } & Record<string, any>;

function resolvePatterns(): string[] {
  // ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÅ‡∏´‡∏•‡πà‡∏á‡πÄ‡∏î‡∏µ‡∏¢‡∏ß‡πÉ‡∏´‡πâ‡∏ä‡∏±‡∏î‡πÄ‡∏à‡∏ô ‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô‡πÇ‡∏´‡∏•‡∏î‡∏ã‡πâ‡∏≥
  if (useDist) return ['dist/commands/**/*.js'];
  // ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡∏™‡πà‡∏á --dist ‡πÉ‡∏´‡πâ‡πÉ‡∏ä‡πâ src; ‡∏Å‡∏±‡∏ô‡πÄ‡∏ú‡∏•‡∏≠‡πÇ‡∏´‡∏•‡∏î‡∏ó‡∏±‡πâ‡∏á‡∏Ñ‡∏π‡πà
  return ['src/commands/**/*.ts'];
}

async function collect(): Promise<{ file: string; json: CmdJSON }[]> {
  const patterns = resolvePatterns();
  const files = await fg(patterns, { dot: false, unique: true });
  const out: { file: string; json: CmdJSON }[] = [];

  for (const f of files) {
    const mod = await import(pathToFileURL(f).href);
    const c = (mod.default ?? mod) as any;
    const json = c?.data?.toJSON?.() as CmdJSON | undefined;
    if (json) out.push({ file: f, json });
  }
  return out;
}

function assertNoDuplicates(items: { file: string; json: CmdJSON }[]) {
  // Discord ‡∏ö‡∏±‡∏á‡∏Ñ‡∏±‡∏ö‡∏ä‡∏∑‡πà‡∏≠‡πÑ‡∏°‡πà‡∏ã‡πâ‡∏≥ (‡∏û‡∏¥‡∏à‡∏≤‡∏£‡∏ì‡∏≤ type ‡∏î‡πâ‡∏ß‡∏¢: 1=slash, 2=user, 3=message)
  const keyOf = (j: CmdJSON) => `${j.name}:${j.type ?? 1}`;
  const seen = new Map<string, { first: string; others: string[] }>();

  for (const it of items) {
    const k = keyOf(it.json);
    const cur = seen.get(k);
    if (!cur) seen.set(k, { first: it.file, others: [] });
    else cur.others.push(it.file);
  }

  const dups = [...seen.entries()].filter(([, v]) => v.others.length > 0);
  if (dups.length) {
    console.error('‚ùå Duplicate command names detected:\n');
    for (const [k, v] of dups) {
      console.error(`- ${k}`);
      console.error(`  first : ${v.first}`);
      v.others.forEach((f, i) => console.error(`  dup #${i + 1}: ${f}`));
    }
    throw new Error('Duplicate command names. Please rename or consolidate (use subcommands).');
  }
}

async function main() {
  if (!token || !clientId) throw new Error('Missing DISCORD_TOKEN or DISCORD_CLIENT_ID');
  if (isGuild && !guildId) throw new Error('Missing DEV_GUILD_ID for --guild');

  const entries = await collect();

  // ‡πÅ‡∏™‡∏î‡∏á‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏Å‡πà‡∏≠‡∏ô‡∏≠‡∏±‡∏õ‡πÇ‡∏´‡∏•‡∏î (‡∏ä‡πà‡∏ß‡∏¢‡πÑ‡∏•‡πà debug)
  console.table(
    entries.map((e, i) => ({
      idx: i,
      name: e.json.name,
      type: e.json.type ?? 1,
      file: e.file,
    }))
  );

  // ‡∏Å‡∏±‡∏ô‡∏ä‡∏∑‡πà‡∏≠‡∏ã‡πâ‡∏≥‡πÅ‡∏ö‡∏ö‡∏ä‡∏±‡∏î‡πÄ‡∏à‡∏ô
  assertNoDuplicates(entries);

  const body = entries.map((e) => e.json);

  if (dryRun) {
    console.log(`üß™ DRY RUN ‚Äì would register ${body.length} command(s).`);
    return;
  }

  const rest = new REST({ version: '10' }).setToken(token);

  if (isGuild) {
    await rest.put(Routes.applicationGuildCommands(clientId, guildId), { body });
    console.log(`‚úÖ Registered ${body.length} guild command(s) to ${guildId}`);
  } else {
    await rest.put(Routes.applicationCommands(clientId), { body });
    console.log(`‚úÖ Registered ${body.length} global command(s)`);
  }
}

main().catch((e) => {
  console.error(e);
  process.exit(1);
});
